FILE: expectedType.kt
    public abstract class FirProperty : R|kotlin/Any| {
        public constructor(): R|FirProperty| {
            super<R|kotlin/Any|>()
        }

        public abstract val returnTypeRef: R|FirTypeRef|
            public get(): R|FirTypeRef|

    }
    public abstract class FirTypeRef : R|kotlin/Any| {
        public constructor(): R|FirTypeRef| {
            super<R|kotlin/Any|>()
        }

    }
    public abstract class FirResolvedTypeRef : R|FirTypeRef| {
        public constructor(): R|FirResolvedTypeRef| {
            super<R|FirTypeRef|>()
        }

        public abstract val type: R|ConeKotlinType|
            public get(): R|ConeKotlinType|

    }
    public abstract class ConeKotlinType : R|kotlin/Any| {
        public constructor(): R|ConeKotlinType| {
            super<R|kotlin/Any|>()
        }

    }
    public final inline fun <reified C : R|ConeKotlinType|> R|FirTypeRef|.coneTypeSafe(): R|C?| {
        ^coneTypeSafe ((this@R|/coneTypeSafe| as? R|FirResolvedTypeRef|)?.{ $subj$.R|/FirResolvedTypeRef.type| } as? R|C|)
    }
    public final class Session : R|kotlin/Any| {
        public constructor(property: R|FirProperty|): R|Session| {
            super<R|kotlin/Any|>()
        }

        public final val property: R|FirProperty| = R|<local>/property|
            public get(): R|FirProperty|

        public final val expectedType: R|ConeKotlinType?|by <Inapplicable(INAPPLICABLE): kotlin/lazy>#<R|ConeKotlinType|>(<L> = lazy@fun <anonymous>(): R|ConeKotlinType| <inline=NoInline>  {
            ^ this@R|/Session|.R|/Session.property|.R|/FirProperty.returnTypeRef|.<Inapplicable(INAPPLICABLE): /coneTypeSafe>#<R|ConeKotlinType|>()
        }
        )
            public get(): R|ConeKotlinType?| {
                ^ this@R|/Session|.D|/Session.expectedType|.R|kotlin/getValue|<R|ConeKotlinType?|>(this@R|/Session|, ::R|/Session.expectedType|)
            }

    }
